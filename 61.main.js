(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[61],{

/***/ "./src/coins/nem.js":
/*!**************************!*\
  !*** ./src/coins/nem.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = async function () {\n  const nem = (await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(0), __webpack_require__.e(2), __webpack_require__.e(3), __webpack_require__.e(5), __webpack_require__.e(6), __webpack_require__.e(7), __webpack_require__.e(4), __webpack_require__.e(8), __webpack_require__.e(10), __webpack_require__.e(11), __webpack_require__.e(26), __webpack_require__.e(37)]).then(__webpack_require__.t.bind(null, /*! ./nem-sdk */ \"./src/coins/nem-sdk/index.js\", 7))).default;\n  const randomBytes = (await Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(54)]).then(__webpack_require__.t.bind(null, /*! randombytes */ \"./node_modules/randombytes/browser.js\", 7))).default;\n  const Coin = await __webpack_require__.e(/*! import() */ 12).then(__webpack_require__.t.bind(null, /*! ./coin */ \"./src/coins/coin.js\", 7));\n  const result = class NEM extends Coin {\n    constructor(name, donate, network) {\n      super(name, donate);\n      this.network = network || nem.network.data.mainnet.id;\n    }\n\n    _create(pk) {\n      const kp = nem.keyPair.create(pk);\n      return kp;\n    }\n\n    create(d, Q, opts) {\n      return this._create(d.toBuffer().toString(\"hex\"));\n    }\n\n    makeRandom(opts) {\n      return this._create(randomBytes(32).toString(\"hex\"));\n    }\n\n    isPrivateKey(key) {\n      key = `${key}`.toLowerCase();\n\n      if (key.startsWith(\"0x\")) {\n        key = key.slice(2);\n      }\n\n      return /^[0-9a-f]{64}$/.test(key);\n    }\n\n    decodePrivateKey(key) {\n      key = `${key}`.toLowerCase();\n\n      if (key.startsWith(\"0x\")) {\n        key = key.slice(2);\n      }\n\n      return this._create(key);\n    } // correspond to getAddressFormatNames, getAddressTitleNames\n\n\n    getAddressWith(key, mode) {\n      switch (mode) {\n        default:\n          //console.log(nem.address.toAddress(Buffer.from(\"9DBF2EF1AA678759CFF2F2C4D57BEAA8E7DA198A7E14B68F2A22ABBB5675AF8A\",\"hex\"), this.network));\n          return nem.address.toAddress(key.publicKey, this.network);\n      }\n    } // correspond to getAddressFormatNames, getAddressTitleNames\n\n\n    getWIFForAddress(key, mode) {\n      switch (mode) {\n        default:\n          return key.secretKey.toString(\"hex\");\n      }\n    } // correspond to getWIFTitleNames\n\n\n    getWIFByType(key, mode) {\n      switch (mode) {\n        default:\n          return key.secretKey.toString(\"hex\");\n      }\n    }\n\n    getAddressFormatNames() {\n      return [\"Normal\"];\n    }\n\n    getAddressTitleNames() {\n      return [\"Public Address\"];\n    }\n\n    getWIFTitleNames() {\n      return [\"Private Key\"];\n    }\n\n    getPublicKey(key, compressed) {\n      return key.publicKey;\n    }\n\n    getPrivateKeyBuffer(key) {\n      return key.secretKey;\n    }\n\n    havePrivateKey(key) {\n      return true;\n    }\n\n    isVanitygenPossible(pattern, mode) {\n      if (!pattern) return true;\n      pattern = pattern.toUpperCase();\n      const prefix = nem.network.id2Char(this.network);\n      const regex = new RegExp(`^${prefix}[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{0,39}$`);\n      return regex.test(pattern);\n    }\n\n    testVanitygenMatch(pattern, address, mode) {\n      pattern = pattern.toUpperCase();\n      address = address.toUpperCase();\n      return address.startsWith(pattern);\n    }\n\n    isUnsure() {\n      return \"nem\";\n    }\n\n  };\n  result.mainnet = nem.network.data.mainnet.id;\n  result.testnet = nem.network.data.testnet.id;\n  result.mijin = nem.network.data.mijin.id;\n  return result;\n}();\n\nmodule.exports.__esModule = true;\n\n//# sourceURL=webpack:///./src/coins/nem.js?");

/***/ })

}]);