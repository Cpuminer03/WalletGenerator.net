(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[22],{

/***/ "./src/coins/bitcoin.js":
/*!******************************!*\
  !*** ./src/coins/bitcoin.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = async function () {\n  const bitcoin = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(3), __webpack_require__.e(5), __webpack_require__.e(6), __webpack_require__.e(7), __webpack_require__.e(4), __webpack_require__.e(8), __webpack_require__.e(10), __webpack_require__.e(11), __webpack_require__.e(24)]).then(__webpack_require__.t.bind(null, /*! bitgo-utxo-lib */ \"./node_modules/bitgo-utxo-lib/src/index.js\", 7));\n  const wif = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(25)]).then(__webpack_require__.t.bind(null, /*! wif */ \"./node_modules/wif/index.js\", 7));\n  const bigi = await Promise.all(/*! import() */[__webpack_require__.e(4), __webpack_require__.e(8), __webpack_require__.e(33)]).then(__webpack_require__.t.bind(null, /*! bigi */ \"./node_modules/bigi/lib/index.js\", 7));\n  const elliptic = await Promise.all(/*! import() */[__webpack_require__.e(3), __webpack_require__.e(21)]).then(__webpack_require__.t.bind(null, /*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\", 7));\n  const Coin = await __webpack_require__.e(/*! import() */ 12).then(__webpack_require__.t.bind(null, /*! ./coin */ \"./src/coins/coin.js\", 7));\n  const constants = await __webpack_require__.e(/*! import() */ 58).then(__webpack_require__.t.bind(null, /*! ./constants */ \"./src/coins/constants.js\", 7)); // \"([0-9]|\\[[0-9]{2}\\])\", \"([a-zA-Z]|\\[[a-zA-Z]{2}\\])\",\n\n  return class Bitcoin extends Coin {\n    constructor(name, networkVersion, privateKeyPrefix, donate, scriptHash, b32hrp, coin = bitcoin.coins.BTC) {\n      super(name, donate);\n      this.network = {\n        messagePrefix: \"\\x18Bitcoin Signed Message:\\n\",\n        bech32: b32hrp,\n        bip32: {\n          public: 0x0488b21e,\n          private: 0x0488ade4\n        },\n        pubKeyHash: networkVersion & 0xffff,\n        scriptHash: scriptHash || 0x05,\n        wif: privateKeyPrefix,\n        coin\n      };\n    }\n\n    create(d, Q, opts) {\n      opts = Object.assign({}, opts || {}, {\n        network: this.network\n      });\n      return new bitcoin.ECPair(d, Q, opts);\n    }\n\n    makeRandom(opts) {\n      opts = Object.assign({}, opts || {}, {\n        network: this.network\n      });\n      return bitcoin.ECPair.makeRandom(opts);\n    }\n\n    isPrivateKey(key) {\n      try {\n        // WIF/CWIF\n        wif.decode(key);\n        return true;\n      } catch (e) {} // Hex/Base64\n\n\n      const testValue = function (buffer) {\n        if (buffer.length !== 32) return false;\n        const n = bigi.fromByteArrayUnsigned(elliptic.curves.secp256k1.curve.n.toArray());\n        const scalar = bigi.fromByteArrayUnsigned(buffer);\n        return n.compareTo(scalar) > 0;\n      };\n\n      if (testValue(Buffer.from(key, \"hex\"))) return true;\n      if (testValue(Buffer.from(key, \"base64\"))) return true; // Mini key\n\n      if (/^S[1-9A-HJ-NP-Za-km-z]{29}$/.test(key)) {\n        const sha256 = bitcoin.crypto.sha256(key + \"?\");\n\n        if (sha256[0] === 0x00) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    decodePrivateKey(key) {\n      if (!this.isPrivateKey(key)) {\n        return null;\n      } // WIF/CWIF\n\n\n      try {\n        return bitcoin.ECPair.fromWIF(key, this.network);\n      } catch (error) {} // Base64/Hex\n\n\n      function tryBy(enc) {\n        try {\n          const hex = Buffer.from(key, enc).toString(\"hex\");\n\n          if (hex.length === 64) {\n            return this.create(bigi.fromHex(hex), null, {\n              compressed: true\n            });\n          }\n        } catch (error) {}\n      }\n\n      const hex = tryBy(\"hex\");\n      if (hex) return hex;\n      const base64 = tryBy(\"base64\");\n      if (base64) return base64;\n\n      if (/^S[1-9A-HJ-NP-Za-km-z]{29}$/.test(key)) {\n        const sha256 = bitcoin.crypto.sha256(key).toString(\"hex\");\n        return this.create(bigi.fromHex(sha256), null, {\n          compressed: true\n        });\n      }\n    } // correspond to getAddressFormatNames, getAddressTitleNames\n\n\n    getAddressWith(btcKey, mode) {\n      const compressed = btcKey.compressed;\n\n      try {\n        switch (mode || 0) {\n          default:\n          case 0:\n            // compressed\n            btcKey.compressed = true;\n            return bitcoin.ECPair.prototype.getAddress.call(btcKey);\n\n          case 1:\n            // uncompressed\n            btcKey.compressed = false;\n            return bitcoin.ECPair.prototype.getAddress.call(btcKey);\n\n          case 2:\n            // segwit\n            if (btcKey.network.bech32) {\n              const pubKeyCompressed = btcKey.Q.getEncoded(true);\n              const redeemScript = bitcoin.script.witnessPubKeyHash.output.encode(bitcoin.crypto.hash160(pubKeyCompressed));\n              return bitcoin.address.toBech32(bitcoin.script.compile(redeemScript).slice(2, 22), 0, btcKey.network.bech32);\n            }\n\n            return this.getAddressWith(btcKey, 0);\n\n          case 3:\n            // segwit (p2sh)\n            if (btcKey.network.bech32) {\n              const pubKeyCompressed = btcKey.Q.getEncoded(true);\n              const redeemScript = bitcoin.script.witnessPubKeyHash.output.encode(bitcoin.crypto.hash160(pubKeyCompressed));\n              const scriptPubKey = bitcoin.crypto.hash160(redeemScript);\n              return bitcoin.address.toBase58Check(scriptPubKey, btcKey.network.scriptHash);\n            }\n\n            return this.getAddressWith(btcKey, 0);\n        }\n      } finally {\n        btcKey.compressed = compressed;\n      }\n    } // correspond to getAddressFormatNames, getAddressTitleNames\n\n\n    getWIFForAddress(btcKey, mode) {\n      const compressed = btcKey.compressed;\n\n      try {\n        switch (mode) {\n          case 1:\n            // uncompressed\n            btcKey.compressed = false;\n            break;\n\n          default:\n            // other\n            btcKey.compressed = true;\n            break;\n        }\n\n        return btcKey.toWIF();\n      } finally {\n        btcKey.compressed = compressed;\n      }\n    } // correspond to getWIFTitleNames\n\n\n    getWIFByType(btcKey, mode) {\n      const compressed = btcKey.compressed;\n\n      try {\n        switch (mode) {\n          case 0:\n            // compressed\n            btcKey.compressed = true;\n            break;\n\n          case 1:\n            // uncompressed\n            btcKey.compressed = false;\n            break;\n        }\n\n        return btcKey.toWIF();\n      } finally {\n        btcKey.compressed = compressed;\n      }\n    }\n\n    getAddressFormatNames() {\n      if (this.network.bech32) {\n        return [\"Compressed\", \"Uncompressed\", \"SegWit\", \"SegWit (P2SH-wrapped)\" // no cashaddress\n        ];\n      } else {\n        return [\"Compressed\", \"Uncompressed\" // no segwit\n        // no cashaddress\n        ];\n      }\n    }\n\n    getAddressTitleNames() {\n      if (this.network.bech32) {\n        return [\"Public Address Compressed\", \"Public Address\", \"SegWit Address\", \"SegWit Address (P2SH-wrapped)\" // no cashaddress\n        ];\n      } else {\n        return [\"Public Address Compressed\", \"Public Address\" // no segwit\n        // no cashaddress\n        ];\n      }\n    }\n\n    getWIFTitleNames() {\n      return [\"Private Key WIF Compressed<br />52 characters Base58\", \"Private Key WIF<br />51 characters Base58\"];\n    }\n\n    getPublicKey(btcKey, compressed) {\n      return btcKey.Q.getEncoded(compressed);\n    }\n\n    getPrivateKeyBuffer(btcKey) {\n      return btcKey.d.toBuffer();\n    }\n\n    havePrivateKey(btcKey) {\n      return !!btcKey.d;\n    }\n\n    isVanitygenPossible(pattern, mode) {\n      if (!pattern) return true;\n      const btcB58 = \"[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{0,34}$\";\n\n      function testBase58(version) {\n        const headRegex = constants.bitcoinB58Leading[version];\n        const regex = new RegExp(`^${headRegex}${btcB58}`);\n        return regex.test(pattern);\n      }\n\n      const self = this;\n\n      function testBech32() {\n        const regex = new RegExp(`^${self.network.bech32}(1(q([abcdefghijklmnopqrstuvwxyz234567]{0,38})?)?)?$`);\n        return regex.test(pattern);\n      }\n\n      switch (mode || 0) {\n        default:\n        case 0: // compressed\n\n        case 1:\n          // uncompressed\n          return testBase58(this.network.pubKeyHash);\n\n        case 2:\n          // segwit\n          if (this.network.bech32) {\n            pattern = pattern.toLowerCase();\n            return testBech32();\n          }\n\n          return false;\n\n        case 3:\n          // segwit (p2sh)\n          if (this.network.bech32) {\n            return testBase58(this.network.scriptHash);\n          }\n\n          return false;\n      }\n    }\n\n  };\n}();\n\nmodule.exports.__esModule = true;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/coins/bitcoin.js?");

/***/ })

}]);